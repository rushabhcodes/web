

===== components/background.mdx =====

---
title: The Background component
sidebarTitle: '<Background />'
description:
  'The Background component makes it convenient to render different types of
  backgrounds common in node-based UIs. It comes with three variants: lines,
  dots and cross.'
---

# \<Background />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/Background.tsx)

The `<Background />` component makes it convenient to render different types of
backgrounds common in node-based UIs. It comes with three variants: `lines`,
`dots` and `cross`.

```jsx
import { useState } from 'react';
import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>
      <Background color="#ccc" variant={BackgroundVariant.Dots} />
    </ReactFlow>
  );
}
```

## Props

<APIDocs componentName="Background" />

## Examples

### Combining multiple backgrounds

It is possible to layer multiple `<Background />` components on top of one another
to create something more interesting. The following example shows how to render a
square grid accented every 10th line.

```tsx
import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';

import '@xyflow/react/dist/style.css';

export default function Flow() {
  return (
    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>
      <Background
        id="1"
        gap={10}
        color="#f1f1f1"
        variant={BackgroundVariant.Lines}
      />

      <Background
        id="2"
        gap={100}
        color="#ccc"
        variant={BackgroundVariant.Lines}
      />
    </ReactFlow>
  );
}
```

## Notes

* When combining multiple `<Background />` components it's important to give each
  of them a unique `id` prop!


===== components/base-edge.mdx =====

---
title: The BaseEdge component
sidebarTitle: '<BaseEdge />'
description:
  'The BaseEdge component gets used internally for all the edges. It can be used
  inside a custom edge and handles the invisible helper edge and the edge label
  for you.'
---

# \<BaseEdge />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/BaseEdge.tsx)

The `<BaseEdge />` component gets used internally for all the edges. It can be
used inside a custom edge and handles the invisible helper edge and the edge label
for you.

```jsx
import { BaseEdge } from '@xyflow/react';

export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {
  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  const { label, labelStyle, markerStart, markerEnd, interactionWidth } = props;

  return (
    <BaseEdge
      path={edgePath}
      label={label}
      labelStyle={labelStyle}
      markerEnd={markerEnd}
      markerStart={markerStart}
      interactionWidth={interactionWidth}
    />
  );
}
```

## Props

<APIDocs componentName="BaseEdge" groupKeys="Omit<SVGAttributes<SVGPathElement>, 'd' | 'path' | 'markerStart' | 'markerEnd'>" />

## Notes

* If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,
  you can pass the `markerStart` or `markerEnd` props passed to your custom edge
  through to the [`<BaseEdge />`](/api-reference/components/base-edge) component. You can see all the props
  passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.


===== components/control-button.mdx =====

---
title: The ControlButton component
sidebarTitle: '<ControlButton />'
description:
  'You can add buttons to the control panel by using the ControlButton component
  and pass it as a child to the Controls component.'
---

# \<ControlButton />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/ControlButton.tsx)

You can add buttons to the control panel by using the `<ControlButton />` component
and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.

```jsx
import { MagicWand } from '@radix-ui/react-icons'
import { ReactFlow, Controls, ControlButton } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} edges={[...]}>
      <Controls>
        <ControlButton onClick={() => alert('Something magical just happened. âœ¨')}>
          <MagicWand />
        </ControlButton>
      </Controls>
    </ReactFlow>
  )
}
```

## Props

The `<ControlButton />` component accepts any prop valid on a HTML `<button />`
element.

<APIDocs componentName="ControlButton" groupKeys="ButtonHTMLAttributes<HTMLButtonElement>" />


===== components/controls.mdx =====

---
title: The Controls component
sidebarTitle: '<Controls />'
description:
  'The Controls component renders a small panel that contains convenient buttons
  to zoom in, zoom out, fit the view, and lock the viewport.'
---

# \<Controls />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Controls/Controls.tsx)

The `<Controls />` component renders a small panel that contains convenient
buttons to zoom in, zoom out, fit the view, and lock the viewport.

```tsx
import { ReactFlow, Controls } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} edges={[...]}>
      <Controls />
    </ReactFlow>
  )
}
```

## Props

For TypeScript users, the props type for the `<Controls />` component is exported
as `ControlProps`.

<APIDocs componentName="Controls" />

## Notes

* To extend or customize the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button)
  component


===== components/edge-label-renderer.mdx =====

---
title: The EdgeLabelRenderer component
sidebarTitle: '<EdgeLabelRenderer />'
description:
  'Edges are SVG-based. If you want to render more complex labels you can use the
  EdgeLabelRenderer component to access a div based renderer. This component is a
  portal that renders the label in a div that is positioned on top of the edges.
  You can see an example usage of the component in the edge label renderer example.'
---

# \<EdgeLabelRenderer />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/EdgeLabelRenderer/index.tsx)

Edges are SVG-based. If you want to render more complex labels you can use the
`<EdgeLabelRenderer />` component to access a div based renderer. This component
is a portal that renders the label in a `<div />` that is positioned on top of
the edges. You can see an example usage of the component in the [edge label renderer](/examples/edges/edge-label-renderer)
example.

```jsx
import React from 'react';
import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';

const CustomEdge = ({ id, data, ...props }) => {
  const [edgePath, labelX, labelY] = getBezierPath(props);

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
      <EdgeLabelRenderer>
        <div
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
            background: '#ffcc00',
            padding: 10,
            borderRadius: 5,
            fontSize: 12,
            fontWeight: 700,
          }}
          className="nodrag nopan"
        >
          {data.label}
        </div>
      </EdgeLabelRenderer>
    </>
  );
};

export default CustomEdge;
```

## Props

<APIDocs componentName="EdgeLabelRenderer" />

## Notes

* The `<EdgeLabelRenderer />` has no pointer events by default. If you want to
  add mouse interactions you need to set the style `pointerEvents: 'all'` and add
  the `nopan` class on the label or the element you want to interact with.


===== components/edge-text.mdx =====

---
title: The EdgeText component
sidebarTitle: '<EdgeText />'
description:
  'You can use the EdgeText component as a helper component to display text within
  your custom edges.'
---

# \<EdgeText />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/EdgeText.tsx)

You can use the `<EdgeText />` component as a helper component to display text
within your custom edges.

```jsx
import { EdgeText } from '@xyflow/react';

export function CustomEdgeLabel({ label }) {
  return (
    <EdgeText
      x={100}
      y={100}
      label={label}
      labelStyle={{ fill: 'white' }}
      labelShowBg
      labelBgStyle={{ fill: 'red' }}
      labelBgPadding={[2, 4]}
      labelBgBorderRadius={2}
    />
  );
}
```

## Props

For TypeScript users, the props type for the `<EdgeText />` component is exported
as `EdgeTextProps`.

<APIDocs componentName="EdgeText" groupKeys="Omit<SVGAttributes<SVGElement>, 'x' | 'y'>" />

Additionally, you may also pass any standard React HTML attributes such as `onClick`,
`className` and so on.


===== components/handle.mdx =====

---
title: The Handle component
sidebarTitle: '<Handle />'
description: 'The Handle component is used in your custom nodes to define connection points.'
---

# \<Handle />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Handle/index.tsx)

The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)
to define connection points.

```jsx
import { Handle, Position } from '@xyflow/react';

export const CustomNode = ({ data }) => {
  return (
    <>
      <div style={{ padding: '10px 20px' }}>
        {data.label}
      </div>

      <Handle type="target" position={Position.Left} />
      <Handle type="source" position={Position.Right} />
    </>
  );
};
```

## Props

For TypeScript users, the props type for the `<Handle />` component is exported
as `HandleProps`.

<APIDocs componentName="Handle" groupKeys="Omit<ComponentProps<'div'>, 'id'>" />


===== components/index.mdx =====

---
asIndexPage: true
---

import { ApiReferenceSummary } from 'xy-shared/server';

# Components

<ApiReferenceSummary category="components" />


===== components/minimap.mdx =====

---
title: The MiniMap component
sidebarTitle: '<MiniMap />'
description:
  'The MiniMap component can be used to render an overview of your flow. It renders
  each node as an SVG element and visualizes where the current viewport is in
  relation to the rest of the flow.'
---

# \<MiniMap />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/MiniMap/MiniMap.tsx)

The `<MiniMap />` component can be used to render an overview of your flow. It
renders each node as an SVG element and visualizes where the current viewport is
in relation to the rest of the flow.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeStrokeWidth={3} />
    </ReactFlow>
  );
}
```

## Props

For TypeScript users, the props type for the `<MiniMap />` component is exported
as `MiniMapProps`.

<APIDocs componentName="MiniMap" groupKeys="Omit<HTMLAttributes<SVGSVGElement>, 'onClick'>" />

## Examples

### Making the mini map interactive

By default, the mini map is non-interactive. To allow users to interact with the
viewport by panning or zooming the minimap, you can set either of the `zoomable`
or `pannable` (or both!) props to `true`.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap pannable zoomable />
    </ReactFlow>
  );
}
```

### Implement a custom mini map node

It is possible to pass a custom component to the `nodeComponent` prop to change
how nodes are rendered in the mini map. If you do this you **must** use only
SVG elements in your component if you want it to work correctly.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeComponent={MiniMapNode} />
    </ReactFlow>
  );
}

function MiniMapNode({ x, y }) {
  return <circle cx={x} cy={y} r="50" />;
}
```

Check out the documentation for [`MiniMapNodeProps`](/api-reference/types/mini-map-node-props)
to see what props are passed to your custom component.

### Customising mini map node color

The `nodeColor`, `nodeStrokeColor`, and `nodeClassName` props can be a function
that takes a [`Node`](/api-reference/types/node) and computes a value for the prop. This can
be used to customize the appearance of each mini map node.

This example shows how to color each mini map node based on the node's type:

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeColor={nodeColor} />
    </ReactFlow>
  );
}

function nodeColor(node) {
  switch (node.type) {
    case 'input':
      return '#6ede87';
    case 'output':
      return '#6865A5';
    default:
      return '#ff0072';
  }
}
```

## TypeScript

This component accepts a generic type argument of custom node types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
<MiniMap<CustomNodeType> nodeColor={nodeColor} />
```


===== components/node-resize-control.mdx =====

---
title: The NodeResizeControl component
sidebarTitle: '<NodeResizeControl />'
description:
  'To create your own resizing UI, you can use the NodeResizeControl component
  where you can pass children (such as icons).'
---

# \<NodeResizeControl />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizeControl.tsx)

To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).

## Props

For TypeScript users, the props type for the `<NodeResizeControl />` component is exported
as `ResizeControlProps`.

<APIDocs componentName="NodeResizeControl" />


===== components/node-resizer.mdx =====

---
title: The NodeResizer component
sidebarTitle: '<NodeResizer />'
description:
  'The NodeResizer component can be used to add a resize functionality to your
  nodes. It renders draggable controls around the node to resize in all directions.'
---

import { RemoteCodeViewer } from 'xy-shared/server';

# \<NodeResizer />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizer.tsx)

The `<NodeResizer />` component can be used to add a resize functionality to your
nodes. It renders draggable controls around the node to resize in all directions.

```jsx
import { memo } from 'react';
import { Handle, Position, NodeResizer } from '@xyflow/react';

const ResizableNode = ({ data }) => {
  return (
    <>
      <NodeResizer minWidth={100} minHeight={30} />
      <Handle type="target" position={Position.Left} />
      <div style={{ padding: 10 }}>{data.label}</div>
      <Handle type="source" position={Position.Right} />
    </>
  );
};

export default memo(ResizableNode);
```

## Props

For TypeScript users, the props type for the `<NodeResizer />` component is exported
as `NodeResizerProps`.

<APIDocs componentName="NodeResizer" />

## Examples

Head over to the [example page](/examples/nodes/node-resizer) to see how this is done.

<RemoteCodeViewer route="examples/nodes/node-resizer" framework="react" />

### Custom Resize Controls

To build custom resize controls, you can use the [NodeResizeControl](/api-reference/components/node-resize-control) component and customize it.

## Notes

* Take a look at the docs for the [`NodeProps`](/api-reference/types/node-props) type or the
  guide on [custom nodes](/learn/customization/custom-nodes) to see how to
  implement your own nodes.


===== components/node-toolbar.mdx =====

---
title: The NodeToolbar component
sidebarTitle: '<NodeToolbar />'
description:
  "The NodeToolbar component can render a toolbar or tooltip to one side of a
  custom node. This toolbar doesn't scale with the viewport so that the content
  is always visible."
---

# \<NodeToolbar />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeToolbar/NodeToolbar.tsx)

This component can render a toolbar or tooltip to one side of a custom node. This
toolbar doesn't scale with the viewport so that the content is always visible.

```jsx
import { memo } from 'react';
import { Handle, Position, NodeToolbar } from '@xyflow/react';

const CustomNode = ({ data }) => {
  return (
    <>
      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>
        <button>delete</button>
        <button>copy</button>
        <button>expand</button>
      </NodeToolbar>

      <div style={{ padding: '10px 20px' }}>
        {data.label}
      </div>

      <Handle type="target" position={Position.Left} />
      <Handle type="source" position={Position.Right} />
    </>
  );
};

export default memo(CustomNode);
```

## Props

For TypeScript users, the props type for the `<NodeToolbar />` component is exported
as `NodeToolbarProps`. Additionally, the `<NodeToolbar />` component accepts all props of the HTML `<div />`
element.

<APIDocs componentName="NodeToolbar" groupKeys="HTMLAttributes<HTMLDivElement>" />

## Notes

* By default, the toolbar is only visible when a node is selected. If multiple
  nodes are selected it will not be visible to prevent overlapping toolbars or
  clutter. You can override this behavior by setting the `isVisible` prop to
  `true`.


===== components/panel.mdx =====

---
title: The Panel component
sidebarTitle: '<Panel />'
description:
  'The Panel component helps you position content above the viewport. It is used
  internally by the MiniMap and Controls components.'
---

# \<Panel />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Panel/index.tsx)

The `<Panel />` component helps you position content above the viewport. It is
used internally by the [`<MiniMap />`](/api-reference/components/minimap) and [`<Controls />`](/api-reference/components/controls)
components.

```jsx
import { ReactFlow, Panel } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} fitView>
      <Panel position="top-left">top-left</Panel>
      <Panel position="top-center">top-center</Panel>
      <Panel position="top-right">top-right</Panel>
      <Panel position="bottom-left">bottom-left</Panel>
      <Panel position="bottom-center">bottom-center</Panel>
      <Panel position="bottom-right">bottom-right</Panel>
      <Panel position="center-left">center-left</Panel>
      <Panel position="center-right">center-right</Panel>
    </ReactFlow>
  );
}
```

## Props

For TypeScript users, the props type for the `<Panel />` component is exported
as `PanelProps`. Additionally, the `<Panel />` component accepts all props of the HTML `<div />`
element.

<APIDocs componentName="Panel" groupKeys="ComponentProps<'div'>" />


===== components/viewport-portal.mdx =====

---
title: The ViewportPortal component
sidebarTitle: '<ViewportPortal />'
description: 'The ViewportPortal component can be used to add components to the same viewport of the flow where nodes and edges are rendered. This is useful when you want to render your own components that are adhere to the same coordinate system as the nodes & edges and are also affected by zooming and panning'
created_at: 2024-02-21
---

# \<ViewportPortal />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ViewportPortal/index.tsx)

`<ViewportPortal />` component can be used to add components to the same viewport of the flow where nodes and edges are rendered.
This is useful when you want to render your own components that adhere to the same coordinate system as the nodes & edges and are also
affected by zooming and panning

```jsx
import React from 'react';
import { ViewportPortal } from '@xyflow/react';

export default function () {
  return (
    <ViewportPortal>
      <div
        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}
      >
        This div is positioned at [100, 100] on the flow.
      </div>
    </ViewportPortal>
  );
}
```

## Props

<APIDocs componentName="ViewportPortal" />


===== hooks/index.mdx =====

---
asIndexPage: true
---

import { ApiReferenceSummary } from 'xy-shared/server';

# Hooks

<ApiReferenceSummary category="hooks" />


===== hooks/use-connection.mdx =====

---
description:
  The useConnection hook returns the current connection when there is an active
  connection interaction. If no connection interaction is active, it returns null
  for every property. A typical use case for this hook is to colorize handles
  based on a certain condition (e.g. if the connection is valid or not).
---

# useConnection()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useConnection.ts)

The `useConnection` hook returns the current connection state when there is an active connection interaction. If no connection interaction is active, it returns `null` for every property. A typical use case for this hook is to colorize handles based on a certain condition (e.g. if the connection is valid or not).

```tsx
import { useConnection } from '@xyflow/react';

export default function App() {
  const connection = useConnection();

  return (
    <div>
      {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}
    </div>
  );
}
```

## Signature

<APIDocs functionName="useConnection" />


===== hooks/use-edges-state.mdx =====

---
description:
  "This hook makes it easy to prototype a controlled flow where you manage the
  state of nodes and edges outside the ReactFlowInstance. You can think of it
  like React's `useState` hook with an additional helper callback."
---

# useEdgesState()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)

This hook makes it easy to prototype a controlled flow where you manage the
state of nodes and edges outside the `ReactFlowInstance`. You can think of it
like React's `useState` hook with an additional helper callback.

```jsx
import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';

const initialNodes = [];
const initialEdges = [];

export default function () {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
    />
  );
}
```

## Signature

<APIDocs functionName="useEdgesState" />

## TypeScript

This hook accepts a generic type argument of custom edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useEdgesState<CustomEdgeType>();
```

## Notes

* This hook was created to make prototyping easier and our documentation
  examples clearer. Although it is OK to use this hook in production, in
  practice you may want to use a more sophisticated state management solution
  like [Zustand](/docs/guides/state-management/) instead.


===== hooks/use-edges.mdx =====

---
description:
  'This hook returns an array of the current edges. Components that use this hook
  will re-render whenever any edge changes.'
---

# useEdges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useEdges.ts)

This hook returns an array of the current edges. Components that use this hook
will re-render **whenever any edge changes**.

```jsx
import { useEdges } from '@xyflow/react';

export default function () {
  const edges = useEdges();

  return <div>There are currently {edges.length} edges!</div>;
}
```

## Signature

<APIDocs functionName="useEdges" />

## TypeScript

This hook accepts a generic type argument of custom edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useEdges<CustomEdgeType>();
```

## Notes

* Relying on `useEdges` unnecessarily can be a common cause of performance
  issues. Whenever any edge changes, this hook will cause the component to
  re-render. Often we actually care about something more specific, like when
  the *number* of edges changes: where possible try to use
  [`useStore`](/api-reference/hooks/use-store) instead.


===== hooks/use-handle-connections.mdx =====

---
description:
  'This hook returns an array of the current edges. Components that use this hook
  will re-render whenever any edge changes.'
created_at: 2024-07-09
---

# useHandleConnections()

> \[!WARNING]
>
> `useHandleConnections` is deprecated in favor of the more capable
> [useNodeConnections](/api-reference/hooks/use-node-connections).

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useHandleConnections.ts)

This hook returns an array connections on a specific handle or handle type.

```jsx
import { useHandleConnections } from '@xyflow/react';

export default function () {
  const connections = useHandleConnections({ type: 'target', id: 'my-handle' });

  return (
    <div>There are currently {connections.length} incoming connections!</div>
  );
}
```

## Signature

<APIDocs functionName="useHandleConnections" />


===== hooks/use-internal-node.mdx =====

---
description: 'This hook returns an InternalNode object for the given node ID.'
---

# useInternalNode()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useInternalNode.ts)

This hook returns the internal representation of a specific node. Components that use this hook
will re-render **whenever any node changes**, including when a node is selected
or moved.

```jsx
import { useInternalNode } from '@xyflow/react';

export default function () {
  const internalNode = useInternalNode('node-1');
  const absolutePosition = internalNode.internals.positionAbsolute;

  return (
    <div>
      The absolute position of the node is at:
      <p>x: {absolutePosition.x}</p>
      <p>y: {absolutePosition.y}</p>
    </div>
  );
}
```

## Signature

<APIDocs functionName="useInternalNode" />

## TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const internalNode = useInternalNode<CustomNodeType>();
```


===== hooks/use-key-press.mdx =====

---
description:
  'This hook lets you listen for specific key codes and tells you whether they are
  currently pressed or not.'
---

# useKeyPress()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useKeyPress.ts)

This hook lets you listen for specific key codes and tells you whether they are
currently pressed or not.

```jsx
import { useKeyPress } from '@xyflow/react';

export default function () {
  const spacePressed = useKeyPress('Space');
  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);

  return (
    <div>
      {spacePressed && <p>Space pressed!</p>}
      {cmdAndSPressed && <p>Cmd + S pressed!</p>}
    </div>
  );
}
```

## Signature

<APIDocs functionName="useKeyPress" />

## Notes

* This hook does not rely on a `ReactFlowInstance` so you are free to use it
  anywhere in your app!


===== hooks/use-node-connections.mdx =====

---
description:
  'This hook returns an array of connected edges. Components that use this hook
  will re-render whenever any edge changes.'
created_at: 2025-01-15
---

# useNodeConnections()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodeConnections.ts)

This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.

```jsx
import { useNodeConnections } from '@xyflow/react';

export default function () {
  const connections = useNodeConnections({
    handleType: 'target',
    handleId: 'my-handle',
  });

  return (
    <div>There are currently {connections.length} incoming connections!</div>
  );
}
```

## Signature

<APIDocs functionName="useNodeConnections" />


===== hooks/use-node-id.mdx =====

---
description:
  "You can use this hook to get the id of the node it is used inside. It is useful
  if you need the node's id deeper in the render tree but don't want to manually
  drill down the id as a prop."
---

# useNodeId()

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/core/src/contexts/NodeIdContext.ts/#L7)

You can use this hook to get the id of the node it is used inside. It is useful
if you need the node's id deeper in the render tree but don't want to manually
drill down the id as a prop.

```js
import { useNodeId } from '@xyflow/react';

export default function CustomNode() {
  return (
    <div>
      <span>This node has an id of </span>
      <NodeIdDisplay />
    </div>
  );
}

function NodeIdDisplay() {
  const nodeId = useNodeId();

  return <span>{nodeId}</span>;
}
```

## Signature

<APIDocs functionName="useNodeId" />

## Notes

* This hook should only be used within a custom node or its children.


===== hooks/use-nodes-data.mdx =====

---
description: 'With this hook you can subscribe to changes of a node data of a specific node.'
created_at: 2024-07-09
---

# useNodesData()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesData.ts)

This hook lets you subscribe to changes of a specific nodes `data` object.

```jsx
import { useNodesData } from '@xyflow/react';

export default function () {
  const nodeData = useNodesData('nodeId-1');

  const nodesData = useNodesData(['nodeId-1', 'nodeId-2']);
}
```

## Signature

<APIDocs functionName="useNodesData" />

## TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodesData = useNodesData<NodesType>(['nodeId-1', 'nodeId-2']);
```


===== hooks/use-nodes-initialized.mdx =====

---
description:
  'This hook tells you whether all the nodes in a flow have been measured and given
  a width and height. When you add a node to the flow, this hook will return
  false and then true again once the node has been measured.'
---

# useNodesInitialized()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesInitialized.ts)

This hook tells you whether all the nodes in a flow have been measured and given
a width and height. When you add a node to the flow, this hook will return
`false` and then `true` again once the node has been measured.

```jsx
import { useReactFlow, useNodesInitialized } from '@xyflow/react';
import { useEffect, useState } from 'react';

const options = {
  includeHiddenNodes: false,
};

export default function useLayout() {
  const { getNodes } = useReactFlow();
  const nodesInitialized = useNodesInitialized(options);
  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());

  useEffect(() => {
    if (nodesInitialized) {
      setLayoutedNodes(yourLayoutingFunction(getNodes()));
    }
  }, [nodesInitialized]);

  return layoutedNodes;
}
```

## Signature

<APIDocs functionName="useNodesInitialized" />

## Notes

* This hook always returns `false` if the internal nodes array is empty.


===== hooks/use-nodes-state.mdx =====

---
description:
  "This hook makes it easy to prototype a controlled flow where you manage the
  state of nodes and edges outside the ReactFlowInstance. You can think of it
  like React's `useState` hook with an additional helper callback."
---

# useNodesState()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)

This hook makes it easy to prototype a controlled flow where you manage the
state of nodes and edges outside the `ReactFlowInstance`. You can think of it
like React's `useState` hook with an additional helper callback.

```jsx
import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';

const initialNodes = [];
const initialEdges = [];

export default function () {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
    />
  );
}
```

## Signature

<APIDocs functionName="useNodesState" />

## TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useNodesState<CustomNodeType>();
```

## Notes

* This hook was created to make prototyping easier and our documentation
  examples clearer. Although it is OK to use this hook in production, in
  practice you may want to use a more sophisticated state management solution
  like [Zustand](/docs/guides/state-management/) instead.


===== hooks/use-nodes.mdx =====

---
description:
  'This hook returns an array of the current nodes. Components that use this hook
  will re-render whenever any node changes, including when a node is selected or
  moved.'
---

# useNodes()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodes.ts)

This hook returns an array of the current nodes. Components that use this hook
will re-render **whenever any node changes**, including when a node is selected
or moved.

```jsx
import { useNodes } from '@xyflow/react';

export default function () {
  const nodes = useNodes();

  return <div>There are currently {nodes.length} nodes!</div>;
}
```

## Signature

<APIDocs functionName="useNodes" />

## TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useNodes<CustomNodeType>();
```

## Notes

* Relying on `useNodes` unnecessarily can be a common cause of performance
  issues. Whenever any node changes, this hook will cause the component to
  re-render. Often we actually care about something more specific, like when
  the *number* of nodes changes: where possible try to use
  [`useStore`](/api-reference/hooks/use-store) instead.


===== hooks/use-on-selection-change.mdx =====

---
description:
  'This hook lets you listen for changes to both node and edge selection. As the
  name implies, the callback you provide will be called whenever the selection of
  either nodes or edges changes.'
---

# useOnSelectionChange()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnSelectionChange.ts)

This hook lets you listen for changes to both node and edge selection. As the
name implies, the callback you provide will be called whenever the selection of
*either* nodes or edges changes.

> \[!WARNING]
>
> You need to memoize the passed `onChange` handler, otherwise the hook will not
> work correctly.

```jsx
import { useState } from 'react';
import { ReactFlow, useOnSelectionChange } from '@xyflow/react';

function SelectionDisplay() {
  const [selectedNodes, setSelectedNodes] = useState([]);
  const [selectedEdges, setSelectedEdges] = useState([]);

  // the passed handler has to be memoized, otherwise the hook will not work correctly
  const onChange = useCallback(({ nodes, edges }) => {
    setSelectedNodes(nodes.map((node) => node.id));
    setSelectedEdges(edges.map((edge) => edge.id));
  }, []);

  useOnSelectionChange({
    onChange,
  });

  return (
    <div>
      <p>Selected nodes: {selectedNodes.join(', ')}</p>
      <p>Selected edges: {selectedEdges.join(', ')}</p>
    </div>
  );
}
```

## Signature

<APIDocs functionName="useOnSelectionChange" />

## Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.


===== hooks/use-on-viewport-change.mdx =====

---
description:
  'The useOnViewportChange hook lets you listen for changes to the viewport such
  as panning and zooming. You can provide a callback for each phase of a viewport
  change: onStart, onChange, and onEnd.'
---

# useOnViewportChange()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnViewportChange.ts)

The `useOnViewportChange` hook lets you listen for changes to the viewport such
as panning and zooming. You can provide a callback for each phase of a viewport
change: `onStart`, `onChange`, and `onEnd`.

```tsx
import { useCallback } from 'react';
import { useOnViewportChange } from '@xyflow/react';

function ViewportChangeLogger() {
  useOnViewportChange({
    onStart: (viewport: Viewport) => console.log('start', viewport),
    onChange: (viewport: Viewport) => console.log('change', viewport),
    onEnd: (viewport: Viewport) => console.log('end', viewport),
  });

  return null;
}
```

## Signature

<APIDocs functionName="useOnViewportChange" />

## Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.


===== hooks/use-react-flow.mdx =====

---
description:
  'This hook returns a ReactFlowInstance that can be used to update nodes and
  edges, manipulate the viewport, or query the current state of the flow.'
---

# useReactFlow()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useReactFlow.ts)

This hook returns a [`ReactFlowInstance`](/api-reference/types/react-flow-instance) that can
be used to update nodes and edges, manipulate the viewport, or query the current
state of the flow.

```jsx
import { useCallback, useState } from 'react';
import { useReactFlow } from '@xyflow/react';

export function NodeCounter() {
  const reactFlow = useReactFlow();
  const [count, setCount] = useState(0);
  const countNodes = useCallback(() => {
    setCount(reactFlow.getNodes().length);
    // you need to pass it as a dependency if you are using it with useEffect or useCallback
    // because at the first render, it's not initialized yet and some functions might not work.
  }, [reactFlow]);

  return (
    <div>
      <button onClick={countNodes}>Update count</button>
      <p>There are {count} nodes in the flow.</p>
    </div>
  );
}
```

## Signature

<APIDocs functionName="useReactFlow" />

## TypeScript

This hook accepts a generic type argument of custom node & edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const reactFlow = useReactFlow<CustomNodeType, CustomEdgeType>();
```

## Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.
* Unlike [`useNodes`](/api-reference/hooks/use-nodes) or [`useEdges`](/api-reference/hooks/use-edges), this hook won't
  cause your component to re-render when state changes. Instead, you can query
  the state when you need it by using methods on the [`ReactFlowInstance`](/api-reference/types/react-flow-instance)
  this hook returns.


===== hooks/use-store-api.mdx =====

---
description:
  'In some cases, you might need to access the store directly. This hook returns
  the store object which can be used on demand to access the state or dispatch
  actions.'
---

# useStoreApi()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)

In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.

> \[!NOTE]
>
> This hook should only be used if there is no other way to access the internal
> state. For many of the common use cases, there are dedicated hooks available
> such as [`useReactFlow`](/api-reference/hooks/use-react-flow),
> [`useViewport`](/api-reference/hooks/use-viewport), etc.

```tsx
import { useState, useCallback } from 'react';
import { ReactFlow, useStoreApi } from '@xyflow/react';

const NodesLengthDisplay = () => {
  const [nodesLength, setNodesLength] = useState(0);
  const store = useStoreApi();

  const onClick = useCallback(() => {
    const { nodes } = store.getState();
    const length = nodes.length || 0;

    setNodesLength(length);
  }, [store]);

  return (
    <div>
      <p>The current number of nodes is: {nodesLength}</p>
      <button onClick={onClick}>Update node length.</button>
    </div>
  );
};

function Flow() {
  return (
    <ReactFlow nodes={nodes}>
      <NodesLengthLogger />
    </ReactFlow>
  );
}
```

This example computes the number of nodes in the flow *on-demand*. This is in
contrast to the example in the [`useStore`](/api-reference/hooks/use-store) hook that re-renders
the component whenever the number of nodes changes.

Choosing whether to calculate values on-demand or to subscribe to changes as they
happen is a bit of a balancing act. On the one hand, putting too many heavy
calculations in an event handler can make your app feel sluggish or unresponsive.
On the other hand, computing values eagerly can lead to slow or unnecessary
re-renders.

We make both this hook and [`useStore`](/api-reference/hooks/use-store) available so that you can
choose the approach that works best for your use-case.

## Signature

<APIDocs functionName="useStoreApi" />

## TypeScript

This hook accepts a generic type argument of custom node & edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const store = useStoreApi<CustomNodeType, CustomEdgeType>();
```


===== hooks/use-store.mdx =====

---
description:
  'This hook can be used to subscribe to internal state changes of the React Flow
  component. The useStore hook is re-exported from the Zustand state management
  library, so you should check out their docs for more details.'
---

import { Callout } from 'nextra/components';

# useStore()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)

This hook can be used to subscribe to internal state changes of the React Flow
component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)
state management library, so you should check out their docs for more details.

<Callout type="info">
  This hook should only be used if there is no other way to access the internal
  state. For many of the common use cases, there are dedicated hooks available
  such as [`useReactFlow`](/api-reference/hooks/use-react-flow),
  [`useViewport`](/api-reference/hooks/use-viewport), etc.
</Callout>

```jsx
import { ReactFlow, useStore } from '@xyflow/react';

const nodesLengthSelector = (state) =>
  state.nodes.length || 0;

const NodesLengthDisplay = () => {
  const nodesLength = useStore(nodesLengthSelector);

  return <div>The current number of nodes is: {nodesLength}</div>;
};

function Flow() {
  return (
    <ReactFlow nodes={[...]}>
      <NodesLengthDisplay />
    </ReactFlow>
  );
}
```

This example computes the number of nodes eagerly. Whenever the number of nodes
in the flow changes, the `<NodesLengthDisplay />` component will re-render. This
is in contrast to the example in the [`useStoreApi`](/api-reference/hooks/use-store-api) hook that only
computes the number of nodes when a button is clicked.

Choosing whether to calculate values on-demand or to subscribe to changes as they
happen is a bit of a balancing act. On the one hand, putting too many heavy
calculations in an event handler can make your app feel sluggish or unresponsive.
On the other hand, computing values eagerly can lead to slow or unnecessary
re-renders.

We make both this hook and [`useStoreApi`](/api-reference/hooks/use-store-api) available so that you
can choose the approach that works best for your use-case.

## Signature

<APIDocs functionName="useStore" />

## Examples

### Triggering store actions

You can manipulate the internal React Flow state by triggering internal actions
through the `useStore` hook. These actions are already used internally throughout
the library, but you can also use them to implement custom functionality.

```jsx
import { useStore } from '@xyflow/react';

const setMinZoomSelector = (state) => state.setMinZoom;

function MinZoomSetter() {
  const setMinZoom = useStore(setMinZoomSelector);

  return <button onClick={() => setMinZoom(6)}>set min zoom</button>;
}
```

## TypeScript

This hook can be typed by typing the selector function. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useStore((s: ReactFlowState<CustomNodeType>) => s.nodes);
```


===== hooks/use-update-node-internals.mdx =====

---
description:
  "When you programmatically add or remove handles to a node or update a node's
  handle position, you need to let React Flow know about it using this hook. This
  will update the internal dimensions of the node and properly reposition handles
  on the canvas if necessary."
---

# useUpdateNodeInternals()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useUpdateNodeInternals.ts)

When you programmatically add or remove handles to a node or update a node's
handle position, you need to let React Flow know about it using this hook. This
will update the internal dimensions of the node and properly reposition handles
on the canvas if necessary.

```jsx
import { useCallback, useState } from 'react';
import { Handle, useUpdateNodeInternals } from '@xyflow/react';

export default function RandomHandleNode({ id }) {
  const updateNodeInternals = useUpdateNodeInternals();
  const [handleCount, setHandleCount] = useState(0);
  const randomizeHandleCount = useCallback(() => {
    setHandleCount(Math.floor(Math.random() * 10));
    updateNodeInternals(id);
  }, [id, updateNodeInternals]);

  return (
    <>
      {Array.from({ length: handleCount }).map((_, index) => (
        <Handle
          key={index}
          type="target"
          position="left"
          id={`handle-${index}`}
        />
      ))}

      <div>
        <button onClick={randomizeHandleCount}>Randomize handle count</button>
        <p>There are {handleCount} handles on this node.</p>
      </div>
    </>
  );
}
```

## Signature

<APIDocs functionName="useUpdateNodeInternals" />

## Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.


===== hooks/use-viewport.mdx =====

---
description:
  'The useViewport hook is a convenient way to read the current state of the
  Viewport in a component. Components that use this hook will re-render whenever
  the viewport changes.'
---

# useViewport()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useViewport.ts)

The `useViewport` hook is a convenient way to read the current state of the
[`Viewport`](/api-reference/types/viewport) in a component. Components that use this hook
will re-render **whenever the viewport changes**.

```jsx
import { useViewport } from '@xyflow/react';

export default function ViewportDisplay() {
  const { x, y, zoom } = useViewport();

  return (
    <div>
      <p>
        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.
      </p>
    </div>
  );
}
```

## Signature

<APIDocs functionName="useViewport" />

## Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.


===== index.mdx =====

import { ContentGrid, ContentGridItem } from '@xyflow/xy-ui';
import { BlogPostPreview } from 'xy-shared';

# API Reference

This reference attempts to document every function, hook, component, and type
exported by React Flow. If you are looking for guides and tutorials, please refer to our [learn section](/learn).

## How to use this reference

We think that documentation should answer two broad
questions: "what is this thing?" and "how do I use it?"

To that end, our API reference aims to **concisely** answer that first question
and learn section goes into more detail on the second. If you find yourself clicking
around the reference wondering what the heck any of this means, maybe we have a
guide that can help you out!

<ContentGrid className="mt-8">
  <ContentGridItem route="/learn/customization/custom-nodes">
    <BlogPostPreview title="Custom nodes" intro="A powerful feature of React Flow is the ability to add custom nodes. Within your custom nodes you can render everything you want. You can define multiple source and target handles and render form inputs or charts for example. In this guide we will implement a node with an input field that updates some text in another part of the application." />
  </ContentGridItem>

  <ContentGridItem route="/learn/layouting/layouting">
    <BlogPostPreview title="Layouting" intro="We regularly get asked how to handle layouting in React Flow. While we could build some basic layouting into React Flow, we believe that you know your app's requirements best and with so many options out there we think it's better you choose the best right tool for the job. In this guide we'll look at four layouting libraries and how to use them." />
  </ContentGridItem>
</ContentGrid>

## A note for our long-term users

If you're coming here from our old API pages things might look a bit different!
We've reorganized our documentation to make it easier to look things up if you
know what you're looking for. All our types, components, hooks, and util functions
get their own page now to help you find exactly what you need.

If you're new to React Flow or you're not sure where to look for something, take
a look at the section below.

## A note for JavaScript users

React Flow is written in TypeScript, but we know that not everyone uses it. We
encourage developers to use the technology that works best for them, and
throughout our documentation there is a blend of TypeScript and JavaScript
examples.

For our API reference, however, we use TypeScript's syntax to document the types
of props and functions. Here's a quick crash course on how to read it:

â€¢ `?` means that the field or argument is optional.

â€¢ `<T>` in a type definition represents a generic type parameter. Like a function
argument but for types! The definition `type Array<T> = ...` means a type called
`Array` that takes a generic type parameter `T`.

â€¢ `<T>` when referring to a type is like "filling in" a generic type parameter.
It's like calling a function but for types! The type `Array<number>` is the
type `Array` with the generic type parameter `T` filled in with the type
`number`.

â€¢ `T | U` means that the type is either `T` or `U`: this is often called a
*union*.

â€¢ `T & U` means that the type is both `T` and `U`: this is often called an
*intersection*.

The TypeScript folks have their own
[handy guide for reading types](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
that you might find useful. If you're still stuck on something, feel free to
drop by our [Discord](https://discord.com/invite/RVmnytFmGW) and ask for help!


===== react-flow-provider.mdx =====

---
title: The ReactFlowProvider component
sidebarTitle: <ReactFlowProvider />
---

# \<ReactFlowProvider />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ReactFlowProvider/index.tsx/#L9)

The `<ReactFlowProvider />` component is a
[context provider](https://react.dev/learn/passing-data-deeply-with-context#) that
makes it possible to access a flow's internal state outside of the
[`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we
provide rely on this component to work.

```tsx
import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlowProvider>
      <ReactFlow nodes={...} edges={...} />
      <Sidebar />
    </ReactFlowProvider>
  )
}

function Sidebar() {
  // This hook will only work if the component it's used in is a child of a
  // <ReactFlowProvider />.
  const nodes = useNodes()

  return (
    <aside>
      {nodes.map((node) => (
        <div key={node.id}>
          Node {node.id} -
            x: {node.position.x.toFixed(2)},
            y: {node.position.y.toFixed(2)}
        </div>
      ))}
    </aside>
  )
}
```

## Props

<APIDocs componentName="ReactFlowProvider" />

## Notes

* If you're using a router and want your flow's state to persist across routes,
  it's vital that you place the `<ReactFlowProvider />` component *outside* of
  your router.
* If you have multiple flows on the same page you will need to use a separate
  `<ReactFlowProvider />` for each flow.


===== react-flow.mdx =====

---
title: The ReactFlow component
sidebarTitle: <ReactFlow />
---

import { ReactFlowAPIProps } from '@/references/ReactFlow.props';

# \<ReactFlow />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/container/ReactFlow/index.tsx/#L47)

The `<ReactFlow />` component is the heart of your React Flow application. It
renders your nodes and edges, handles user interaction, and can manage its own
state if used as an [uncontrolled flow](/learn/advanced-use/uncontrolled-flow).

```tsx
import { ReactFlow } from '@xyflow/react'

export default function Flow() {
  return <ReactFlow
    nodes={...}
    edges={...}
    onNodesChange={...}
    ...
  />
}
```

This component takes a lot of different props, most of which are optional. We've
tried to document them in groups that make sense to help you find your way.

## Common props

These are the props you will most commonly use when working with React Flow. If
you are working with a controlled flow with custom nodes, you will likely use
almost all of these!

<ReactFlowAPIProps group="common" />

## Viewport props

<ReactFlowAPIProps group="viewport" />

## Edge props

<ReactFlowAPIProps group="edge" />

## Event handlers

> \[!WARNING]
>
> It's important to remember to define any event handlers outside of your
> component or using React's `useCallback` hook. If you don't, this can cause
> React Flow to enter an infinite re-render loop!

### General Events

<ReactFlowAPIProps group="generalEvents" />

### Node Events

<ReactFlowAPIProps group="nodeEvents" />

### Edge Events

<ReactFlowAPIProps group="edgeEvents" />

### Connection Events

<ReactFlowAPIProps group="connectionEvents" />

### Pane Events

<ReactFlowAPIProps group="paneEvents" />

### Selection Events

<ReactFlowAPIProps group="selectionEvents" />

## Interaction props

<ReactFlowAPIProps group="interaction" />

## Connection line props

<ReactFlowAPIProps group="connectionLine" />

## Keyboard props

React Flow let's you pass in a few different keyboard shortcuts as another way
to interact with your flow. We've tried to set up sensible defaults like using
backspace to delete any selected nodes or edges, but you can use these props to
set your own.

To disable any of these shortcuts, pass in `null` to the prop you want to
disable.

<ReactFlowAPIProps group="keyboard" />

## Style props

Applying certain classes to elements rendered inside the canvas will change how
interactions are handled. These props let you configure those class names if you
need to.

<ReactFlowAPIProps group="style" />

## Notes

* The props of this component get exported as `ReactFlowProps`


===== types/aria-label-config.mdx =====

---
description: 'With the AriaLabelConfig you can customize the aria labels and descriptions used by React Flow.'
---

# AriaLabelConfig

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/constants.ts/)

With the `AriaLabelConfig` you can customize the aria labels used by React Flow. This is useful if you want to translate the labels or if you want to change them to better suit your application.

## Fields

<APIDocs typeName="AriaLabelConfig" packageName="react" />

## Default config

```js
const defaultAriaLabelConfig = {
  'node.a11yDescription.default':
    'Press enter or space to select a node. Press delete to remove it and escape to cancel.',
  'node.a11yDescription.keyboardDisabled':
    'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',
  'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }: { direction: string; x: number; y: number }) =>
    `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,
  'edge.a11yDescription.default':
    'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',

  // Control elements
  'controls.ariaLabel': 'Control Panel',
  'controls.zoomIn.ariaLabel': 'Zoom In',
  'controls.zoomOut.ariaLabel': 'Zoom Out',
  'controls.fitView.ariaLabel': 'Fit View',
  'controls.interactive.ariaLabel': 'Toggle Interactivity',

  // Mini map
  'minimap.ariaLabel': 'Mini Map',

  // Handle
  'handle.ariaLabel': 'Handle',
};
```


===== types/background-variant.mdx =====

---
description:
  'The three variants are exported as an enum for convenience. You can either import
  the enum and use it like BackgroundVariant.Lines or you can use the raw string
  value directly.'
---

# BackgroundVariant

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/types.ts)

The three variants are exported as an enum for convenience. You can either import
the enum and use it like `BackgroundVariant.Lines` or you can use the raw string
value directly.

```ts
export enum BackgroundVariant {
  Lines = 'lines',
  Dots = 'dots',
  Cross = 'cross',
}
```


===== types/color-mode.mdx =====

---
description: The ColorMode type defines the available color modes for the ReactFlow component.
---

# ColorMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts)

The `ColorMode` type defines the available color modes for the ReactFlow component. This can be used to control the theme of the flow diagram.

```ts
export type ColorMode = 'light' | 'dark' | 'system';
```


===== types/connection-line-component-props.mdx =====

---
description:
  'If you want to render a custom component for connection lines, you can set the
  connectionLineComponent prop on the ReactFlow component. The
  ConnectionLineComponentProps are passed to your custom component.'
---

# ConnectionLineComponentProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L193)

If you want to render a custom component for connection lines, you can set the
`connectionLineComponent` prop on the
[`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineComponent) component.
The `ConnectionLineComponentProps` are passed to your custom component.

## Props

<APIDocs typeName="ConnectionLineComponentProps" />


===== types/connection-line-component.mdx =====

---
description: Custom React component for rendering the connection line during edge creation.
---

# ConnectionLineComponent

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts#L265)

The `ConnectionLineComponent` type allows you to provide a custom React component to render the connection line when users create new edges. The component receives `ConnectionLineComponentProps` as its props.

```ts
type ConnectionLineComponent = React.ComponentType<ConnectionLineComponentProps>;
```


===== types/connection-line-type.mdx =====

---
description:
  'If you set the connectionLineType prop on your ReactFlow component, it will
  dictate the style of connection line rendered when creating new edges.'
---

# ConnectionLineType

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L62)

If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)
component, it will dictate the style of connection line rendered when creating
new edges.

```ts
export enum ConnectionLineType {
  Bezier = 'default',
  Straight = 'straight',
  Step = 'step',
  SmoothStep = 'smoothstep',
  SimpleBezier = 'simplebezier',
}
```

## Notes

* If you choose to render a custom connection line component, this value will be
  passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).


===== types/connection-mode.mdx =====

---
description: Specifies the rules for how connections between nodes are established.
---

# ConnectionMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L68)

The `ConnectionMode` enum provides two options for connection behavior in React Flow:

* `Strict`: Connections can only be made starting from a source handle and ending on a target handle
* `Loose`: Connections can be made between any handles, regardless of type

```ts
enum ConnectionMode {
  Strict = 'strict',
  Loose = 'loose',
}
```


===== types/connection-state.mdx =====

---
description: 'Data about an ongoing connection.'
---

# ConnectionState

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L148-L174)

The `ConnectionState` type bundles all information about an ongoing connection. It is returned by the [`useConnection`](/api-reference/hooks/use-connection) hook.

```ts
type NoConnection = {
  inProgress: false;
  isValid: null;
  from: null;
  fromHandle: null;
  fromPosition: null;
  fromNode: null;
  to: null;
  toHandle: null;
  toPosition: null;
  toNode: null;
};
type ConnectionInProgress = {
  inProgress: true;
  isValid: boolean | null;
  from: XYPosition;
  fromHandle: Handle;
  fromPosition: Position;
  fromNode: NodeBase;
  to: XYPosition;
  toHandle: Handle | null;
  toPosition: Position;
  toNode: NodeBase | null;
};

type ConnectionState = ConnectionInProgress | NoConnection;
```

## Fields

<APIDocs typeName="ConnectionState" />


===== types/connection.mdx =====

---
description:
  'The Connection type is the basic minimal description of an Edge between two nodes. The
  addEdge util can be used to upgrade a Connection to an Edge.'
---

# Connection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L29-L34)

The `Connection` type is the basic minimal description of an
[`Edge`](/api-reference/types/edge) between two nodes. The
[`addEdge`](/api-reference/utils/add-edge) util can be used to upgrade a `Connection` to
an [`Edge`](/api-reference/types/edge).

## Fields

<APIDocs typeName="Connection" />


===== types/coordinate-extent.mdx =====

---
description:
  'A coordinate extent represents two points in a coordinate system: one in the top
  left corner and one in the bottom right corner. It is used to represent the
  bounds of nodes in the flow or the bounds of the viewport.'
---

# CoordinateExtent

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L36-L37)

A coordinate extent represents two points in a coordinate system: one in the top
left corner and one in the bottom right corner. It is used to represent the
bounds of nodes in the flow or the bounds of the viewport.

```ts
export type CoordinateExtent = [[number, number], [number, number]];
```

## Notes

* Props that expect a `CoordinateExtent` usually default to `[[-âˆž, -âˆž], [+âˆž, +âˆž]]`
  to represent an unbounded extent.


===== types/default-edge-options.mdx =====

---
description:
  'Many properties on an Edge are optional. When a new edge is created, the properties
  that are not provided will be filled in with the default values passed to the
  defaultEdgeOptions prop of the ReactFlow component.'
---

# DefaultEdgeOptions

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L88-L89)

Many properties on an [`Edge`](/api-reference/types/edge) are optional. When a new edge is
created, the properties that are not provided will be filled in with the default values
passed to the `defaultEdgeOptions` prop of the
[`<ReactFlow />`](/api-reference/react-flow#defaultedgeoptions) component.

## Fields

<APIDocs typeName="DefaultEdgeOptions" />


===== types/delete-elements.mdx =====

---
description: 'DeleteElements deletes nodes and edges from the flow and return the deleted edges and nodes asynchronously.'
---

# DeleteElements

DeleteElements deletes provided nodes and edges and handles deleting any connected edges as well as child nodes. Returns successfully deleted edges and nodes asynchronously.

```ts
export type DeleteElements = (payload: {
  nodes?: (Partial<Node> & { id: Node['id'] })[];
  edges?: (Partial<Edge> & { id: Edge['id'] })[];
}) => Promise<{
  deletedNodes: Node[];
  deletedEdges: Edge[];
}>;
```


===== types/edge-change.mdx =====

---
description:
  The onEdgesChange callback takes an array of EdgeChange objects that you should
  use to update your flow's state. The EdgeChange type is a union of four different
  object types that represent that various ways an edge can change in a flow.
---

# EdgeChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/changes.ts/#L68-L72)

The [`onEdgesChange`](/api-reference/react-flow#on-edges-change) callback takes
an array of `EdgeChange` objects that you should use to update your flow's state.
The `EdgeChange` type is a union of four different object types that represent that
various ways an edge can change in a flow.

```ts
export type EdgeChange =
  | EdgeAddChange
  | EdgeRemoveChange
  | EdgeReplaceChange
  | EdgeSelectionChange;
```

## Variants

### EdgeAddChange

<APIDocs typeName="EdgeAddChange" />

### EdgeRemoveChange

<APIDocs typeName="EdgeRemoveChange" />

### EdgeReplaceChange

<APIDocs typeName="EdgeReplaceChange" />

### EdgeSelectionChange

<APIDocs typeName="EdgeSelectionChange" />


===== types/edge-marker.mdx =====

---
description:
  Edges can optionally have markers at the start and end of an edge. The EdgeMarker type
  is used to configure those markers! Check the docs for MarkerType for details on what
  types of edge marker are available.
---

# EdgeMarker

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L70-L78)

Edges can optionally have markers at the start and end of an edge. The `EdgeMarker` type
is used to configure those markers! Check the docs for
[`MarkerType`](/api-reference/types/marker-type) for details on what types of edge marker
are available.

## Fields

<APIDocs typeName="EdgeMarker" />


===== types/edge-mouse-handler.mdx =====

---
description: The EdgeMouseHandler type defines the callback function that is called when mouse events occur on an edge.
---

# EdgeMouseHandler

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts#L81)

The `EdgeMouseHandler` type defines the callback function that is called when mouse events occur on an edge. This callback receives the event and the edge that triggered it.

```ts
type EdgeMouseHandler = (event: React.MouseEvent, edge: Edge) => void;
```

<APIDocs typeName="EdgeMouseHandler" packageName="react" />


===== types/edge-props.mdx =====

---
description:
  'When you implement a custom edge it is wrapped in a component that enables some basic
  functionality. Your custom edge component receives the following props:'
---

# EdgeProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L100)

When you implement a custom edge it is wrapped in a component that enables some basic
functionality. The `EdgeProps` type takes a generic parameter to specify the type of edges
you use in your application:

```ts
type AppEdgeProps = EdgeProps<MyEdgeType>;
```

Your custom edge component receives the following props:

## Fields

<APIDocs typeName="EdgeProps" />


===== types/edge-types.mdx =====

---
description: The EdgeTypes type is used to define custom edge types.
---

# EdgeTypes

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L76)

The `EdgeTypes` type is used to define custom edge types. Each key in the object represents an edge type, and the value is the component that should be rendered for that type.

```ts
export type EdgeTypes = {
  [key: string]: React.ComponentType<EdgeProps>;
};
```


===== types/edge.mdx =====

---
description:
  'Where a Connection is the minimal description of an edge between two nodes,
  an `Edge` is the complete description with everything React Flow needs to know
  in order to render it.'
---

# Edge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)

Where a [`Connection`](/api-reference/types/connection) is the minimal description of an edge between
two nodes, an `Edge` is the complete description with everything React Flow needs
to know in order to render it.

```ts
export type Edge<T> = DefaultEdge<T> | SmoothStepEdge<T> | BezierEdge<T>;
```

## Variants

### Edge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)

<APIDocs typeName="Edge" />

### SmoothStepEdge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L45-L46)

The `SmoothStepEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:

{/* type SmoothStepEdge isn't exported, and conflicts with SmoothStepEdge component name */}

<APIDocs
  code={`
type $ = {
type: "smoothstep"
pathOptions?: { offset?: number; borderRadius?: number }
}
export default $
`}
/>

### BezierEdge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L52-L53)

The `BezierEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:

{/* type BezierEdge isn't exported, and conflicts with BezierEdge component name */}

<APIDocs
  code={`
type $ = {
type: "default"
pathOptions?: { curvature?: number }
}
export default $
`}
/>

## Default edge types

You can create any of React Flow's default edges by setting the `type` property
to one of the following values:

* `"default"`
* `"straight"`
* `"step"`
* `"smoothstep"`
* `"simplebezier"`

If you don't set the `type` property at all, React Flow will fallback to the
`"default"` bezier curve edge type.

These default edges are available even if you set the [`edgeTypes`](/api-reference/react-flow#edge-types)
prop to something else, unless you override any of these keys directly.


===== types/fit-view-options.mdx =====

---
description:
  'When calling fitView these options can be used to customize the behavior. For example,
  the duration option can be used to transform the viewport smoothly over a given amount
  of time.'
---

# FitViewOptions

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts/#L67-L68)

When calling [`fitView`](/api-reference/types/react-flow-instance#fitview) these options
can be used to customize the behavior. For example, the `duration` option can be used to
transform the viewport smoothly over a given amount of time.

## Fields

<APIDocs typeName="FitViewOptions" />


===== types/handle-connection.mdx =====

---
description: 'The HandleConnection type is a Connection that includes the edgeId.'
---

# HandleConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)

The `HandleConnection` type is an extension of a basic
[Connection](/api-reference/types/connection) that includes the `edgeId`.

## Fields

<APIDocs typeName="HandleConnection" packageName="system" />


===== types/handle.mdx =====

---
description: 'Handle attributes like id, position, and type.'
---

# Handle

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/handles.ts/#L5)

The `Handle` type represents the attributes of a handle.

## Fields

<APIDocs typeName="Handle" packageName="system" />


===== types/index.mdx =====

---
asIndexPage: true
---

import { ApiReferenceSummary } from 'xy-shared/server';

# Types

<ApiReferenceSummary category="types" />


===== types/internal-node.mdx =====

---
description:
  'The InternalNode is an extension of the base Node type with additional properties React
  Flow uses internally for rendering.'
---

# InternalNode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/99985b52026cf4ac65a1033178cf8c2bea4e14fa/packages/system/src/types/nodes.ts#L68)

The `InternalNode` type is identical to the base [`Node`](/api-references/types/node) type
but is extended with some additional properties used internally by React Flow. Some
functions and callbacks that return nodes may return an `InternalNode`.

## Fields

<APIDocs typeName="InternalNodeBase" packageName="system" />


===== types/is-valid-connection.mdx =====

---
description: Function type that determines whether a connection between nodes is valid.
---

# IsValidConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L212)

The `IsValidConnection` type represents a function that validates whether a connection between nodes is allowed. It receives a [`Connection`](/api-reference/types/connection) and returns a boolean indicating whether the connection is valid and therefore should be created.

```ts
type IsValidConnection = (edge: Edge | Connection) => boolean;
```

<APIDocs typeName="IsValidConnection" packageName="react" />


===== types/key-code.mdx =====

---
description: Represents keyboard key codes or combinations.
---

# KeyCode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L155)

The `KeyCode` type is used to specify keyboard key codes or combinations, such as deleting nodes or enabling multi-selection. It can be a single string or an array of strings representing key codes.

```ts
type KeyCode = string | Array<string>;
```


===== types/marker-type.mdx =====

---
description:
  Edges may optionally have a marker on either end. The MarkerType type enumerates
  the options available to you when configuring a given marker.
---

# MarkerType

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L82-L83)

Edges may optionally have a marker on either end. The MarkerType type enumerates
the options available to you when configuring a given marker.

```ts
export enum MarkerType {
  Arrow = 'arrow',
  ArrowClosed = 'arrowclosed',
}
```


===== types/mini-map-node-props.mdx =====

---
description:
  'The MiniMapNodeProps type defines the properties for nodes in a minimap component.'
---

# MiniMapNodeProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/react/src/additional-components/MiniMap/types.ts/#L60)

The MiniMapNodeProps type defines the props for nodes in the MiniMap component. This is
only relevant if you pass a custom node type to the MiniMap.

## Fields

<APIDocs typeName="MiniMapNodeProps" />

```
```


===== types/node-change.mdx =====

---
description:
  The onNodesChange callback takes an array of NodeChange objects that you should
  use to update your flow's state. The NodeChange type is a union of six different
  object types that represent that various ways an node can change in a flow.
---

# NodeChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/system/src/types/changes.ts/#L47)

The [`onNodesChange`](/api-reference/react-flow#on-nodes-change) callback takes
an array of `NodeChange` objects that you should use to update your flow's state.
The `NodeChange` type is a union of six different object types that represent that
various ways an node can change in a flow.

```ts
export type NodeChange =
  | NodeDimensionChange
  | NodePositionChange
  | NodeSelectionChange
  | NodeRemoveChange
  | NodeAddChange
  | NodeReplaceChange;
```

## Variant types

### NodeDimensionChange

<APIDocs typeName="NodeDimensionChange" />

### NodePositionChange

<APIDocs typeName="NodePositionChange" />

### NodeSelectionChange

<APIDocs typeName="NodeSelectionChange" />

### NodeRemoveChange

<APIDocs typeName="NodeRemoveChange" />

### NodeAddChange

<APIDocs typeName="NodeAddChange" />

### NodeReplaceChange

<APIDocs typeName="NodeReplaceChange" />


===== types/node-connection.mdx =====

---
description: 'The NodeConnection type is a Connection that includes the edgeId.'
---

# NodeConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)

The `NodeConnection` type is an extension of a basic
[Connection](/api-reference/types/connection) that includes the `edgeId`.

## Fields

<APIDocs typeName="NodeConnection" />


===== types/node-handle.mdx =====

---
description: The NodeHandle type is used to define a handle for a node if server side rendering is used.
---

# NodeHandle

[Source on GitHub](https://github.com/xyflow/xyflow/blob/13897512d3c57e72c2e27b14ffa129412289d948/packages/system/src/types/nodes.ts#L139)

The `NodeHandle` type is used to define a handle for a node if server-side rendering is used. On the server, React Flow can't measure DOM nodes, so it's necessary to define the handle position dimensions.

<APIDocs typeName="NodeHandle" packageName="system" />


===== types/node-mouse-handler.mdx =====

---
description: The NodeMouseHandler type defines the callback function that is called when mouse events occur on a node.
---

# NodeMouseHandler

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.tsL32)

The `NodeMouseHandler` type defines the callback function that is called when mouse events occur on a node. This callback receives the event and the node that triggered it.

```ts
export type NodeMouseHandler = (event: React.MouseEvent, node: Node) => void;
```

<APIDocs typeName="NodeMouseHandler" packageName="react" />


===== types/node-origin.mdx =====

---
description: The origin of a Node determines how it is placed relative to its own coordinates.
---

# NodeOrigin

The origin of a Node determines how it is placed relative to its own coordinates.
`[0, 0]` places it at the top left corner, `[0.5, 0.5]` right in the center and `[1, 1]` at the bottom right of its position.

```ts
export type NodeOrigin = [number, number];
```


===== types/node-props.mdx =====

---
title: NodeProps
description:
  'When you implement a custom node it is wrapped in a component that enables basic
  functionality like selection and dragging. Your custom node receives the following
  props:'
---

# NodeProps\<T>

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L89)

When you implement a [custom node](/learn/customization/custom-nodes) it is wrapped in a
component that enables basic functionality like selection and dragging.

## Usage

```tsx
import { useState } from 'react';
import { NodeProps, Node } from '@xyflow/react';

export type CounterNode = Node<
  {
    initialCount?: number;
  },
  'counter'
>;

export default function CounterNode(props: NodeProps<CounterNode>) {
  const [count, setCount] = useState(props.data?.initialCount ?? 0);

  return (
    <div>
      <p>Count: {count}</p>
      <button className="nodrag" onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

Remember to register your custom node by adding it to the
[`nodeTypes`](/api-reference/react-flow#nodetypes) prop of your `<ReactFlow />` component.

```tsx
import { ReactFlow } from '@xyflow/react';
import CounterNode from './CounterNode';

const nodeTypes = {
  counterNode: CounterNode,
};

export default function App() {
  return <ReactFlow nodeTypes={nodeTypes} ... />
}
```

You can read more in our [custom node guide](/learn/customization/custom-nodes).

## Fields

Your custom node receives the following props:

<APIDocs typeName="NodeProps" />


===== types/node-types.mdx =====

---
description: The NodeTypes type is used to define custom node types.
---

# NodeTypes

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts)

The `NodeTypes` type is used to define custom node types. Each key in the object represents a node type, and the value is the component that should be rendered for that type.

```ts
type NodeTypes = {
  [key: string]: React.ComponentType<NodeProps>;
};
```


===== types/node.mdx =====

---
description:
  'The Node type represents everything React Flow needs to know about a given node.
  Many of these properties can be manipulated both by React Flow or by you, but
  some such as width and height should be considered read-only.'
---

# Node

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L10)

The `Node` type represents everything React Flow needs to know about a given node.
Many of these properties can be manipulated both by React Flow or by you, but
some such as `width` and `height` should be considered read-only.

## Fields

<APIDocs typeName="Node" packageName="react" />

## Default node types

You can create any of React Flow's default nodes by setting the `type` property
to one of the following values:

* `"default"`
* `"input"`
* `"output"`
* `"group"`

If you don't set the `type` property at all, React Flow will fallback to the
`"default"` node with both an input and output port.

These default nodes are available even if you set the [`nodeTypes`](/api-reference/react-flow#node-types)
prop to something else, unless you override any of these keys directly.

## Notes

* You shouldn't try to set the `width` or `height` of a node directly. It is
  calculated internally by React Flow and used when rendering the node in the
  viewport. To control a node's size you should use the `style` or `className`
  props to apply CSS styles instead.


===== types/on-before-delete.mdx =====

---
description: The OnBeforeDelete type defines the callback function that is called before nodes or edges are deleted.
---

# OnBeforeDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L207)

The `OnBeforeDelete` type defines the callback function that is called before nodes or edges are deleted. This callback receives an object containing the nodes and edges that are about to be deleted.

```ts
type OnBeforeDelete = (params: {
  nodes: Node[];
  edges: Edge[];
}) => Promise<boolean | {
  nodes: Node[];
  edges: Edge[];
})>;
```

<APIDocs typeName="OnBeforeDelete" packageName="react" />


===== types/on-connect-end.mdx =====

---
description: Callback function triggered when finishing or canceling a connection attempt between nodes.
---

# OnConnectEnd

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L89)

The `OnConnectEnd` type represents a callback function that is called when finishing or canceling a connection attempt. It receives the mouse or touch event and the final state of the connection attempt.

```ts
type OnConnectEnd = (
  event: MouseEvent | TouchEvent,
  connectionState: FinalConnectionState,
) => void;
```

<APIDocs typeName="OnConnectEnd" packageName="system" />


===== types/on-connect-start.mdx =====

---
description: Callback function triggered when starting to create a connection between nodes.
---

# OnConnectStart

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L79)

The `OnConnectStart` type represents a callback function that is called when starting to create a connection between nodes. It receives the mouse or touch event and information about the source node and handle.

```ts
type OnConnectStart = (
  event: MouseEvent | TouchEvent,
  params: OnConnectStartParams,
) => void;
```

<APIDocs typeName="OnConnectStart" packageName="system" />


===== types/on-connect.mdx =====

---
description: Callback function triggered when a new connection is created between nodes.
---

# OnConnect

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L80)

The `OnConnect` type represents a callback function that is called when a new connection is created between nodes. It receives a [`Connection`](/api-reference/types/connection) containing the source and target node IDs and their respective handle IDs.

```ts
type OnConnect = (connection: Connection) => void;
```

<APIDocs typeName="OnConnect" packageName="system" />


===== types/on-delete.mdx =====

---
description: The OnDelete type defines the callback function that is called when nodes or edges are deleted.
---

# OnDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L59)

The `OnDelete` type defines the callback function that is called when nodes or edges are deleted. This callback receives an object containing the deleted nodes and edges.

```ts
type OnDelete = (params: { nodes: Node[]; edges: Edge[] }) => void;
```

<APIDocs typeName="OnDelete" packageName="react" />


===== types/on-edges-change.mdx =====

---
description: ''
---

# OnEdgesChange

This type is used for typing the [`onEdgesChange`](/api-reference/react-flow#on-edges-change) function.

```tsx
export type OnEdgesChange<EdgeType extends Edge = Edge> = (
  changes: EdgeChange<EdgeType>[],
) => void;
```

## Fields

<APIDocs typeName="OnEdgesChange" />

## Usage

This type accepts a generic type argument of custom edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const onEdgesChange: OnEdgesChange = useCallback(
  (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
  [setEdges],
);
```


===== types/on-edges-delete.mdx =====

---
description: The OnEdgesDelete type defines the callback function that is called when edges are deleted.
---

# OnEdgesDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L52)

The `OnEdgesDelete` type defines the callback function that is called when edges are deleted. This callback receives an array of the deleted edges.

```ts
type OnEdgesDelete = (edges: Edge[]) => void;
```

<APIDocs typeName="OnEdgesDelete" packageName="react" />


===== types/on-error.mdx =====

---
description: The OnError type defines the callback function that is called when an error occurs.
---

# OnError

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L233)

The `OnError` type defines the callback function that is called when an error occurs. This callback receives an error id and the error message as its argument.

```ts
type OnError = (id: string, error: string) => void;
```

<APIDocs typeName="OnError" packageName="system" />


===== types/on-init.mdx =====

---
description: The OnInit type defines the callback function that is called when the ReactFlow instance is initialized.
---

# OnInit

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L113)

The `OnInit` type defines the callback function that is called when the ReactFlow instance is initialized. This callback receives the ReactFlow instance as its argument.

```ts
type OnInit = (reactFlowInstance: ReactFlowInstance) => void;
```

<APIDocs typeName="OnInit" packageName="react" />


===== types/on-move.mdx =====

---
description: Invoked when the viewport is moved, such as by panning or zooming.
---

# OnMove

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L16)

The `OnMove` type is a callback that fires whenever the viewport is moved, either by user interaction or programmatically. It receives the triggering event and the new viewport state.

```ts
type OnMove = (event: MouseEvent | TouchEvent | null, viewport: Viewport) => void;
```

<APIDocs typeName="OnMove" packageName="system" />


===== types/on-node-drag.mdx =====

---
description: The OnNodeDrag type defines the callback function that is called when a node is being dragged.
---

# OnNodeDrag

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts#L34)

The `OnNodeDrag` type defines the callback function that is called when a node is being dragged. This callback receives the event and the node that is being dragged.

```ts
type OnNodeDrag = (event: React.MouseEvent, node: Node) => void;
```

<APIDocs typeName="OnNodeDrag" packageName="react" />


===== types/on-nodes-change.mdx =====

---
description: ''
---

# OnNodesChange

This type is used for typing the [`onNodesChange`](/api-reference/react-flow#on-nodes-change) function.

```tsx
export type OnNodesChange<NodeType extends Node = Node> = (
  changes: NodeChange<NodeType>[],
) => void;
```

## Fields

<APIDocs typeName="OnNodesChange" />

## Usage

This type accepts a generic type argument of custom nodes types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const onNodesChange: OnNodesChange = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [setNodes],
);
```


===== types/on-nodes-delete.mdx =====

---
description: The OnNodesDelete type defines the callback function that is called when nodes are deleted.
---

# OnNodesDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L51)

The `OnNodesDelete` type defines the callback function that is called when nodes are deleted. This callback receives an array of the deleted nodes.

```ts
type OnNodesDelete = (nodes: Node[]) => void;
```

<APIDocs typeName="OnNodesDelete" packageName="react" />


===== types/on-reconnect.mdx =====

---
description: Callback function triggered when an existing edge is reconnected to a different node or handle.
---

# OnReconnect

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L83)

The `OnReconnect` type represents a callback function that is called when an existing edge is reconnected to a different node or handle. It receives the old edge and the new connection details.

```ts
type OnReconnect<EdgeType extends EdgeBase = EdgeBase> = (
  oldEdge: EdgeType,
  newConnection: Connection,
) => void;
```

<APIDocs typeName="OnReconnect" packageName="react" />


===== types/on-selection-change-func.mdx =====

---
description: Called whenever the selection of nodes or edges changes in the flow diagram.
---

# OnSelectionChangeFunc

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#98)

The `OnSelectionChangeFunc` type is a callback that is triggered when the selection of nodes or edges changes. It receives an object containing the currently selected nodes and edges.

```ts
type OnSelectionChangeFunc = (params: { nodes: Node[]; edges: Edge[] }) => void;
```

<APIDocs typeName="OnSelectionChangeFunc" packageName="react" />


===== types/pan-on-scroll-mode.mdx =====

---
description: Configures how the viewport responds to scroll events, allowing free, vertical, or horizontal panning.
---

# PanOnScrollMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L166)

The `PanOnScrollMode` enum controls the panning behavior of the viewport when the user scrolls. Choose `Free` for unrestricted panning, `Vertical` for up-and-down only, or `Horizontal` for left-and-right only.

```ts
enum PanOnScrollMode {
  Free = 'free',
  Vertical = 'vertical',
  Horizontal = 'horizontal',
}
```

<APIDocs typeName="PanOnScrollMode" packageName="system" />


===== types/panel-position.mdx =====

---
description:
  'This type is mostly used to help position things on top of the flow viewport.
  For example both the MiniMap and Controls components take a position prop of
  this type.'
---

# PanelPosition

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L111-L112)

This type is mostly used to help position things on top of the flow viewport. For
example both the [`<MiniMap />`](/api-reference/components/minimap) and
[`<Controls />`](/api-reference/components/controls) components take a `position`
prop of this type.

```ts
export type PanelPosition =
  | 'top-left'
  | 'top-center'
  | 'top-right'
  | 'bottom-left'
  | 'bottom-center'
  | 'bottom-right'
  | 'center-left'
  | 'center-right';
```


===== types/position.mdx =====

---
description:
  'While PanelPosition can be used to place a component in the corners of a
  container, the Position enum is less precise and used primarily in relation
  to edges and handles.'
---

# Position

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L1)

While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a component in the
corners of a container, the `Position` enum is less precise and used primarily
in relation to edges and handles.

```ts
export enum Position {
  Left = 'left',
  Top = 'top',
  Right = 'right',
  Bottom = 'bottom',
}
```


===== types/pro-options.mdx =====

---
description:
  'By default, we render a small attribution in the corner of your flows that links back
  to the project.'
---

# ProOptions

By default, we render a small attribution in the corner of your flows that links back to
the project. Anyone is free to remove this attribution whether they're a Pro subscriber or
not but we ask that you take a quick look at our
[removing attribution](/learn/troubleshooting/remove-attribution) guide before doing so.

<APIDocs typeName="ProOptions" />


===== types/react-flow-instance.mdx =====

---
description:
  'The ReactFlowInstance provides a collection of methods to query and manipulate the
  internal state of your flow. You can get an instance by using the useReactFlow hook or
  attaching a listener to the onInit event.'
---

import {
  NodesAndEdgesFields,
  IntersectionFields,
  ViewportFields,
} from '@/references/react-flow-instance';

# ReactFlowInstance

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L178-L179)

The `ReactFlowInstance` provides a collection of methods to query and manipulate the
internal state of your flow. You can get an instance by using the
[`useReactFlow`](/api-reference/hooks/use-react-flow) hook or attaching a listener to the
[`onInit`](/api-reference/react-flow#event-oninit) event.

## Fields

### Nodes and edges

<NodesAndEdgesFields />

### Intersections

<IntersectionFields />

### Viewport

<ViewportFields />


===== types/react-flow-json-object.mdx =====

---
description:
  'A JSON-compatible representation of your flow. You can use this to save the flow to a
  database for example and load it back in later.'
---

# ReactFlowJsonObject

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L5)

A JSON-compatible representation of your flow. You can use this to save the flow to a
database for example and load it back in later.

## Fields

<APIDocs typeName="ReactFlowJsonObject" />


===== types/rect.mdx =====

---
description: The Rect type defines a rectangle with dimensions and a position.
---

# Rect

[Source on GitHub](https://github.com/xyflow/xyflow/blob/f0ce2c876d8688e13632bc86286cf857f86dead6/packages/system/src/types/utils.ts/#L39-L40)

The `Rect` type defines a rectangle in a two-dimensional space with dimensions and a
position.

<APIDocs typeName="Rect" />


===== types/resize-params.mdx =====

---
description:
  The ResizeParams type is used to type the various events that are emitted by the
  NodeResizer component. You'll sometimes see this type extended with an additional
  direction field too.
---

# ResizeParams

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/node-resizer/src/types.ts/#L4)

The `ResizeParams` type is used to type the various events that are emitted by the
`<NodeResizer />` component. You'll sometimes see this type extended with an additional
direction field too.

## Fields

<APIDocs typeName="ResizeParams" />


===== types/selection-drag-handler.mdx =====

---
description: Handles drag events for selected nodes during interactive operations.
---

# SelectionDragHandler

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts#L33)

The `SelectionDragHandler` type is a callback for handling drag events involving selected nodes. It receives the triggering mouse or touch event and an array of the affected nodes.

```ts
type SelectionDragHandler<NodeType extends Node = Node> = (
  event: ReactMouseEvent,
  nodes: NodeType[],
) => void;
```

<APIDocs typeName="SelectionDragHandler" packageName="react" />


===== types/selection-mode.mdx =====

---
description: Controls how nodes are selected in the flow diagram, offering either full or partial selection behavior.
---

# SelectionMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L223)

The `SelectionMode` enum provides two options for node selection behavior:

* `Full`: A node is only selected when the selection rectangle fully contains it
* `Partial`: A node is selected when the selection rectangle partially overlaps with it

```ts
enum SelectionMode {
  Partial = 'partial',
  Full = 'full',
}
```


===== types/snap-grid.mdx =====

---
description: The SnapGrid type defines the grid size for snapping nodes on the pane.
---

# SnapGrid

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L157)

The `SnapGrid` type defines the grid size for snapping nodes on the pane. It is used in conjunction with the `snapToGrid` prop to enable grid snapping functionality.

```ts
type SnapGrid = [number, number];
```


===== types/viewport.mdx =====

---
description:
  'Internally, React Flow maintains a coordinate system that is independent of the rest of
  the page. The Viewport type tells you where in that system your flow is currently being
  display at and how zoomed in or out it is.'
---

# Viewport

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L149-L153)

Internally, React Flow maintains a coordinate system that is independent of the rest of
the page. The `Viewport` type tells you where in that system your flow is currently being
display at and how zoomed in or out it is.

## Fields

<APIDocs typeName="Viewport" />

## Notes

* A `Transform` has the same properties as the viewport, but they represent different
  things. Make sure you don't get them muddled up or things will start to look weird!


===== types/xy-position.mdx =====

---
description: All positions are stored in an object with x and y coordinates.
---

# XYPosition

All positions are stored in an object with x and y coordinates.

```ts
export type XYPosition = {
  x: number;
  y: number;
};
```


===== utils/add-edge.mdx =====

---
description:
  "This util is a convenience function to add a new Edge to an array of edges.
  It also performs some validation to make sure you don't add an invalid edge or
  duplicate an existing one."
---

# addEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/general.ts/#L100)

This util is a convenience function to add a new [`Edge`](/api-reference/types/edge) to an
array of edges. It also performs some validation to make sure you don't add an
invalid edge or duplicate an existing one.

```js
import { useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  useNodesState,
  useEdgesState,
} from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const onConnect = useCallback(
    (connection) => {
      setEdges((oldEdges) => addEdge(connection, oldEdges));
    },
    [setEdges],
  );

  return <ReactFlow nodes={nodes} edges={edges} onConnect={onConnect} />;
}
```

## Signature

<APIDocs functionName="addEdge" />

## Notes

* If an edge with the same `target` and `source` already exists (and the same
  `targetHandle` and `sourceHandle` if those are set), then this util won't add
  a new edge even if the `id` property is different.


===== utils/apply-edge-changes.mdx =====

---
description:
  "Various events on the ReactFlow component can produce an EdgeChange that
  describes how to update the edges of your flow in some way. If you don't need
  any custom behavior, this util can be used to take an array of these changes
  and apply them to your edges."
---

# applyEdgeChanges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L167)

Various events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce an
[`EdgeChange`](/api-reference/types/edge-change) that describes how to update the edges of your
flow in some way. If you don't need any custom behavior, this util can be used to
take an array of these changes and apply them to your edges.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyEdgeChanges } from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const onEdgesChange = useCallback(
    (changes) => {
      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));
    },
    [setEdges],
  );

  return (
    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />
  );
}
```

## Signature

<APIDocs functionName="applyEdgeChanges" />

## Notes

* If you don't need any custom behavior, the [`useEdgesState`](/api-reference/hooks/use-edges-state)
  hook conveniently wraps this util and React's `useState` hook for you and might
  be simpler to use.


===== utils/apply-node-changes.mdx =====

---
description:
  "Various events on the ReactFlow component can produce a NodeChange that
  describes how to update the nodes of your flow in some way. If you don't need
  any custom behavior, this util can be used to take an array of these changes
  and apply them to your nodes."
---

# applyNodeChanges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L140)

Various events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce a
[`NodeChange`](/api-reference/types/node-change) that describes how to update the nodes of your
flow in some way. If you don't need any custom behavior, this util can be used to
take an array of these changes and apply them to your nodes.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyNodeChanges } from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const onNodesChange = useCallback(
    (changes) => {
      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));
    },
    [setNodes],
  );

  return (
    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />
  );
}
```

## Signature

<APIDocs functionName="applyNodeChanges" />

## Notes

* If you don't need any custom behavior, the [`useNodesState`](/api-reference/hooks/use-nodes-state)
  hook conveniently wraps this util and React's `useState` hook for you and might
  be simpler to use.


===== utils/get-bezier-path.mdx =====

---
description:
  'The getBezierPath util returns everything you need to render a bezier edge
  between two nodes.'
---

# getBezierPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/bezier-edge.ts/#L95)

The `getBezierPath` util returns everything you need to render a bezier edge
between two nodes.

```js
import { Position, getBezierPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0,20 C75,20 75,100 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<APIDocs functionName="getBezierPath" />

## Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.


===== utils/get-connected-edges.mdx =====

---
description:
  'Given an array of nodes that may be connected to one another and an array of
  all your edges, this util gives you an array of edges that connect any of the
  given nodes together.'
---

# getConnectedEdges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L224)

This utility filters an array of edges, keeping only those where either the source or target node is present in the given array of nodes.

```js
import { getConnectedEdges } from '@xyflow/react';

const nodes = [
  { id: 'a', position: { x: 0, y: 0 } },
  { id: 'b', position: { x: 100, y: 0 } },
];
const edges = [
  { id: 'a->c', source: 'a', target: 'c' },
  { id: 'c->d', source: 'c', target: 'd' },
];

const connectedEdges = getConnectedEdges(nodes, edges);
// => [{ id: 'a->c', source: 'a', target: 'c' }]
```

## Signature

<APIDocs functionName="getConnectedEdges" />


===== utils/get-incomers.mdx =====

---
description:
  'This util is used to tell you what nodes, if any, are connected to the given node
  as the source of an edge.'
---

# getIncomers()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L91)

This util is used to tell you what nodes, if any, are connected to the given node
as the *source* of an edge.

```ts
import { getIncomers } from '@xyflow/react';

const nodes = [];
const edges = [];

const incomers = getIncomers(
  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },
  nodes,
  edges,
);
```

## Signature

<APIDocs functionName="getIncomers" />


===== utils/get-nodes-bounds.mdx =====

---
description:
  'Returns the bounding box that contains all the given nodes in an array. This can
  be useful when combined with `getViewportForBounds` to calculate the correct
  transform to fit the given nodes in a viewport.'
---

# getNodesBounds()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L133)

Returns the bounding box that contains all the given nodes in an array. This can
be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)
to calculate the correct transform to fit the given nodes in a viewport.

> \[!NOTE]
>
> This function was previously called `getRectOfNodes`

```js
import { getNodesBounds } from '@xyflow/react';

const nodes = [
  {
    id: 'a',
    position: { x: 0, y: 0 },
    data: { label: 'a' },
    width: 50,
    height: 25,
  },
  {
    id: 'b',
    position: { x: 100, y: 100 },
    data: { label: 'b' },
    width: 50,
    height: 25,
  },
];

const bounds = getNodesBounds(nodes);
```

## Signature

<APIDocs functionName="getNodesBounds" />


===== utils/get-outgoers.mdx =====

---
description:
  'This util is used to tell you what nodes, if any, are connected to the given node
  as the target of an edge.'
---

# getOutgoers()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L64)

This util is used to tell you what nodes, if any, are connected to the given node
as the *target* of an edge.

```ts
import { getOutgoers } from '@xyflow/react';

const nodes = [];
const edges = [];

const outgoers = getOutgoers(
  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },
  nodes,
  edges,
);
```

## Signature

<APIDocs functionName="getOutgoers" />


===== utils/get-simple-bezier-path.mdx =====

---
description:
  'The getSimpleBezierPath util returns everything you need to render a simple
  bezier edge between two nodes.'
---

# getSimpleBezierPath()

[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/SimpleBezierEdge.tsx/#L32)

The `getSimpleBezierPath` util returns everything you need to render a simple
bezier edge between two nodes.

```js
import { Position, getSimpleBezierPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getSimpleBezierPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0,20 C75,20 75,100 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<APIDocs functionName="getSimpleBezierPath" />

## Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.


===== utils/get-smooth-step-path.mdx =====

---
description:
  'The getSmoothStepPath util returns everything you need to render a stepped path
  between two nodes. The borderRadius property can be used to choose how rounded
  the corners of those steps are.'
---

# getSmoothStepPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/smoothstep-edge.ts/#L215)

The `getSmoothStepPath` util returns everything you need to render a stepped path
between two nodes. The `borderRadius` property can be used to choose how rounded
the corners of those steps are.

```js
import { Position, getSmoothStepPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0 20L20 20L 70,20Q 75,20 75,25L 75,95Q ..."
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<APIDocs functionName="getSmoothStepPath" />

## Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.
* You can set the `borderRadius` property to `0` to get a step edge path.


===== utils/get-straight-path.mdx =====

---
description: 'Calculates the straight line path between two points.'
---

# getStraightPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/straight-edge.ts/#L30)

Calculates the straight line path between two points.

```js
import { getStraightPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({
  sourceX: source.x,
  sourceY: source.y,
  targetX: target.x,
  targetY: target.y,
});

console.log(path); //=> "M 0,20L 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<APIDocs functionName="getStraightPath" />

## Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.


===== utils/get-viewport-for-bounds.mdx =====

---
description: 'This util returns the viewport for the given bounds.
  You might use this to pre-calculate the viewport for a given set of nodes on the
  server or calculate the viewport for the given bounds _without_ changing the
  viewport directly.'
---

import { Callout } from 'nextra/components';

# getViewportForBounds()

[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/general.ts/#L170)

This util returns the viewport for the given bounds.
You might use this to pre-calculate the viewport for a given set of nodes on the
server or calculate the viewport for the given bounds *without* changing the
viewport directly.

> \[!NOTE]
>
> This function was previously called `getTransformForBounds`

```js
import { getViewportForBounds } from '@xyflow/react';

const { x, y, zoom } = getViewportForBounds(
  {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
  },
  1200,
  800,
  0.5,
  2,
);
```

## Signature

<APIDocs functionName="getViewportForBounds" />

## Notes

* This is quite a low-level utility. You might want to look at the
  [`fitView`](/api-reference/types/react-flow-instance#fitview) or
  [`fitBounds`](/api-reference/types/react-flow-instance#fitbounds) methods for a more practical
  api.


===== utils/index.mdx =====

---
asIndexPage: true
---

import { ApiReferenceSummary } from 'xy-shared/server';

# Utils

<ApiReferenceSummary category="utils" />


===== utils/is-edge.mdx =====

---
description:
  'Test whether an object is usable as an Edge. In TypeScript this is a type
  guard that will narrow the type of whatever you pass in to Edge if it returns
  true.'
---

# isEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L39-L40)

Test whether an object is usable as an [`Edge`](/api-reference/types/edge). In TypeScript
this is a type guard that will narrow the type of whatever you pass in to
[`Edge`](/api-reference/types/edge) if it returns `true`.

```js
import { isEdge } from '@xyflow/react';

const edge = {
  id: 'edge-a',
  source: 'a',
  target: 'b',
};

if (isEdge(edge)) {
  // ...
}
```

## Signature

<APIDocs functionName="isEdge" />


===== utils/is-node.mdx =====

---
description:
  'Test whether an object is usable as a Node. In TypeScript this is a type
  guard that will narrow the type of whatever you pass in to Node if it returns
  true.'
---

# isNode()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L49)

Test whether an object is usable as a [`Node`](/api-reference/types/node). In TypeScript
this is a type guard that will narrow the type of whatever you pass in to
[`Node`](/api-reference/types/node) if it returns `true`.

```js
import { isNode } from '@xyflow/react';

const node = {
  id: 'node-a',
  data: {
    label: 'node',
  },
  position: {
    x: 0,
    y: 0,
  },
};

if (isNode(node)) {
  // ..
}
```

## Signature

<APIDocs functionName="isNode" />


===== utils/reconnect-edge.mdx =====

---
description:
  'A handy utility to reconnect an existing Edge with new properties. This searches
  your edge array for an edge with a matching id and updates its properties with
  the connection you provide.'
---

# reconnectEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/core/src/utils/graph.ts/#L97)

A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.
This searches your edge array for an edge with a matching `id` and updates its
properties with the connection you provide.

```js
const onReconnect = useCallback(
  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),
  []
);
```

## Signature

<APIDocs functionName="reconnectEdge" />
